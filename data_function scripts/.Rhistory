#Visualising the communities
subgraph <- induced_subgraph(graph, v = top_ten$word)
subgraph <- simplify(subgraph)
subgraph$community
nodes = data.frame(word = names(V(subgraph)))
group = rep(1:n, each = nn)
top_ten$group = group
clusters = inner_join(nodes, top_ten)
subgraph$community <- clusters$group
#unique(subgraph$community)
# give our nodes some properties, incl scaling them by degree and coloring them by community
V(subgraph)$size <- 5
V(subgraph)$frame.color <- "white"
V(subgraph)$color <- subgraph$community
#V(male_subgraph)$label <- V(male_subgraph)$name
V(subgraph)$label.cex <- 1.5
# also color edges according to their starting node
edge.start <- ends(subgraph, es = E(subgraph), names = F)[,1]
E(subgraph)$color <- V(subgraph)$color[edge.start]
E(subgraph)$arrow.mode <- 0
# only label central characters
#v_labels <- which(V(friends_graph)$name %in% friends)
#for (i in 1:length(V(friends_graph))) {
#  if (!(i %in% v_labels)) {
#    V(friends_graph)$label[i] <- ""
#  }
#}
#l2 <- layout_with_mds(male_subgraph)
#layout <- layout_with_kk(male_subgraph, weights=weights)
#plot(graph, layout=layout)
#plot(male_subgraph, rescale = T, layout = l2, main = "Male Graph")
#length(V(male_subgraph))
#visIgraph(male_subgraph) %>% visIgraphLayout(layout = "layout_with_mds") %>% visNodes(size = 12)
#layout_in_circle
#"layout_with_mds"
#plot by groups
#make clusters first
clust_obj = make_clusters(subgraph, membership = clusters$group)
# weights <- ifelse(crossing(male_clust, male_subgraph), 1, 100)
# layout <- layout_with_kk(male_subgraph, weights=weights)
# plot(male_subgraph, layout=layout)
prettyColors <- c("turquoise4", "azure4", "olivedrab","deeppink4", "blue")
communityColors <- prettyColors[membership(clust_obj)]
edge.weights <- function(community, network, weight.within = 100, weight.between = 1) {
bridges <- crossing(communities = community, graph = network)
weights <- ifelse(test = bridges, yes = weight.between, no = weight.within)
return(weights)
}
E(subgraph)$weight <- edge.weights(clust_obj, subgraph)
layout <- layout_with_fr(subgraph, weights=E(subgraph)$weight)
plot(subgraph, layout=layout, col = communityColors)
}
detect_communities(token.all, 'male', 10)
#load tokens, get it ready for analysis
load("token.all.RData")
#convert tokens to all lower
token.all <- tokens_tolower(token.all) #convert all tokens to lower
token.all = tokens_sample(token.all, size = 22638, replace = FALSE, prob = NULL, by = decade)
#gender = 'male'
#DETECTING COMMUNITIES
#toks.all = token.all
#gender = 'female'
detect_communities <- function(toks.all, gender = 'male', nn = 10){
toks <- toks.all %>%
tokens_select(pattern = paste(gender, '/characters', sep = ''), selection = 'remove', padding = TRUE, window = 5)
#filter to keep only words that occur at least 10 times
dfm <-  toks %>% dfm() %>% dfm_trim(min_termfreq = 10)
filtered = colnames(dfm)
toks <- token.all %>%
tokens_select(pattern = filtered, selection = 'keep', padding = TRUE)
#feature co-occurrence matrix for males
fcmat = fcm(toks, context = c("window"),
count = c("weighted"), #words are weighted within the window
window = 5)
#fcmat[1:2,1:2] #a small portion of the feature co-occurrence matrix
graph = graph_from_adjacency_matrix(fcmat, weighted = TRUE) #create graph from matrix
edgelist <- get.data.frame(graph)
edgelist_m <- as.matrix(edgelist[ ,c("from", "to")])
graph <- graph_from_edgelist(edgelist_m, directed = FALSE)
graph <- set.edge.attribute(graph, "weight", value = edgelist$weight)
graph = simplify(graph, remove.loops = TRUE) #remove self-looping edges
#louvian communities
louvain <- cluster_louvain(graph, weights = E(graph)$weights)#detect communities
graph$community <- louvain$membership
#unique(male_graph$community)
paste('modularity =', modularity(louvain))
#most important word in each community
communities <- data.frame()
for (i in unique(graph$community)) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# get size of each subgraph
size <- igraph::gorder(subgraph)
# get betweenness centrality
btwn <-  igraph::betweenness(subgraph)
communities <- communities %>%
dplyr::bind_rows(
data.frame(community = i,
n_characters = size,
most_important = names(which(btwn == max(btwn)))
)
)
}
communities = arrange(communities, desc(n_characters))
top_comm <- communities$community[1:5]
#knitr::kable(communities %>%
#               dplyr::select(community, n_characters, most_important))
#top five in each community
top_ten <- data.frame()
n = 0
for (i in top_comm) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# for larger communities
#  if (igraph::gorder(subgraph) > 1055) {
n = n + 1
# get degree
degree <-  igraph::degree(subgraph)
# get top ten degrees
top <- names(head(sort(degree, decreasing = TRUE), nn))
result <- data.frame(community = i, rank = 1:nn, word = top)
# } else {
#   result <- data.frame(community = NULL, rank = NULL, character = NULL)
#}
top_ten <- top_ten %>%
dplyr::bind_rows(result)
}
print(top_ten)
write.csv(top_ten, paste(gender, '.csv', sep = ''))
n
# knitr::kable(
#   top_five %>%
#     tidyr::pivot_wider(names_from = rank, values_from = character)
# )
#Visualising the communities
subgraph <- induced_subgraph(graph, v = top_ten$word)
subgraph <- simplify(subgraph)
subgraph$community
nodes = data.frame(word = names(V(subgraph)))
group = rep(1:n, each = nn)
top_ten$group = group
clusters = inner_join(nodes, top_ten)
subgraph$community <- clusters$group
#unique(subgraph$community)
# give our nodes some properties, incl scaling them by degree and coloring them by community
V(subgraph)$size <- 5
V(subgraph)$frame.color <- "white"
V(subgraph)$color <- subgraph$community
#V(male_subgraph)$label <- V(male_subgraph)$name
V(subgraph)$label.cex <- 1.5
# also color edges according to their starting node
edge.start <- ends(subgraph, es = E(subgraph), names = F)[,1]
E(subgraph)$color <- V(subgraph)$color[edge.start]
E(subgraph)$arrow.mode <- 0
# only label central characters
#v_labels <- which(V(friends_graph)$name %in% friends)
#for (i in 1:length(V(friends_graph))) {
#  if (!(i %in% v_labels)) {
#    V(friends_graph)$label[i] <- ""
#  }
#}
#l2 <- layout_with_mds(male_subgraph)
#layout <- layout_with_kk(male_subgraph, weights=weights)
#plot(graph, layout=layout)
#plot(male_subgraph, rescale = T, layout = l2, main = "Male Graph")
#length(V(male_subgraph))
#visIgraph(male_subgraph) %>% visIgraphLayout(layout = "layout_with_mds") %>% visNodes(size = 12)
#layout_in_circle
#"layout_with_mds"
#plot by groups
#make clusters first
clust_obj = make_clusters(subgraph, membership = clusters$group)
# weights <- ifelse(crossing(male_clust, male_subgraph), 1, 100)
# layout <- layout_with_kk(male_subgraph, weights=weights)
# plot(male_subgraph, layout=layout)
prettyColors <- c("turquoise4", "azure4", "olivedrab","deeppink4", "blue")
communityColors <- prettyColors[membership(clust_obj)]
edge.weights <- function(community, network, weight.within = 100, weight.between = 1) {
bridges <- crossing(communities = community, graph = network)
weights <- ifelse(test = bridges, yes = weight.between, no = weight.within)
return(weights)
}
E(subgraph)$weight <- edge.weights(clust_obj, subgraph)
layout <- layout_with_fr(subgraph, weights=E(subgraph)$weight)
plot(subgraph, layout=layout, col = communityColors)
}
detect_communities(token.all, 'male', 10)
detect_communities(token.all, 'female', 10)
detect_communities(token.all, 'female', 10)
#gender = 'male'
#DETECTING COMMUNITIES
#toks.all = token.all
#gender = 'female'
detect_communities <- function(toks.all, gender = 'male', nn = 10){
toks <- toks.all %>%
tokens_select(pattern = paste(gender, '/characters', sep = ''), selection = 'remove', padding = TRUE, window = 5)
#filter to keep only words that occur at least 10 times
dfm <-  toks %>% dfm() %>% dfm_trim(min_termfreq = 10)
filtered = colnames(dfm)
toks <- token.all %>%
tokens_select(pattern = filtered, selection = 'keep', padding = TRUE)
#feature co-occurrence matrix for males
fcmat = fcm(toks, context = c("window"),
count = c("weighted"), #words are weighted within the window
window = 5)
#fcmat[1:2,1:2] #a small portion of the feature co-occurrence matrix
graph = graph_from_adjacency_matrix(fcmat, weighted = TRUE) #create graph from matrix
edgelist <- get.data.frame(graph)
edgelist_m <- as.matrix(edgelist[ ,c("from", "to")])
graph <- graph_from_edgelist(edgelist_m, directed = FALSE)
graph <- set.edge.attribute(graph, "weight", value = edgelist$weight)
graph = simplify(graph, remove.loops = TRUE) #remove self-looping edges
#louvian communities
louvain <- cluster_louvain(graph, weights = E(graph)$weights)#detect communities
graph$community <- louvain$membership
#unique(male_graph$community)
#most important word in each community
communities <- data.frame()
for (i in unique(graph$community)) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# get size of each subgraph
size <- igraph::gorder(subgraph)
# get betweenness centrality
btwn <-  igraph::betweenness(subgraph)
communities <- communities %>%
dplyr::bind_rows(
data.frame(community = i,
n_characters = size,
most_important = names(which(btwn == max(btwn)))
)
)
}
communities = arrange(communities, desc(n_characters))
top_comm <- communities$community[1:5]
#knitr::kable(communities %>%
#               dplyr::select(community, n_characters, most_important))
#top five in each community
top_ten <- data.frame()
n = 0
for (i in top_comm) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# for larger communities
#  if (igraph::gorder(subgraph) > 1055) {
n = n + 1
# get degree
degree <-  igraph::degree(subgraph)
# get top ten degrees
top <- names(head(sort(degree, decreasing = TRUE), nn))
result <- data.frame(community = i, rank = 1:nn, word = top)
# } else {
#   result <- data.frame(community = NULL, rank = NULL, character = NULL)
#}
top_ten <- top_ten %>%
dplyr::bind_rows(result)
}
print(top_ten)
write.csv(top_ten, paste(gender, '.csv', sep = ''))
print(paste('modularity =', modularity(louvain)))
n
# knitr::kable(
#   top_five %>%
#     tidyr::pivot_wider(names_from = rank, values_from = character)
# )
#Visualising the communities
subgraph <- induced_subgraph(graph, v = top_ten$word)
subgraph <- simplify(subgraph)
subgraph$community
nodes = data.frame(word = names(V(subgraph)))
group = rep(1:n, each = nn)
top_ten$group = group
clusters = inner_join(nodes, top_ten)
subgraph$community <- clusters$group
#unique(subgraph$community)
# give our nodes some properties, incl scaling them by degree and coloring them by community
V(subgraph)$size <- 5
V(subgraph)$frame.color <- "white"
V(subgraph)$color <- subgraph$community
#V(male_subgraph)$label <- V(male_subgraph)$name
V(subgraph)$label.cex <- 1.5
# also color edges according to their starting node
edge.start <- ends(subgraph, es = E(subgraph), names = F)[,1]
E(subgraph)$color <- V(subgraph)$color[edge.start]
E(subgraph)$arrow.mode <- 0
# only label central characters
#v_labels <- which(V(friends_graph)$name %in% friends)
#for (i in 1:length(V(friends_graph))) {
#  if (!(i %in% v_labels)) {
#    V(friends_graph)$label[i] <- ""
#  }
#}
#l2 <- layout_with_mds(male_subgraph)
#layout <- layout_with_kk(male_subgraph, weights=weights)
#plot(graph, layout=layout)
#plot(male_subgraph, rescale = T, layout = l2, main = "Male Graph")
#length(V(male_subgraph))
#visIgraph(male_subgraph) %>% visIgraphLayout(layout = "layout_with_mds") %>% visNodes(size = 12)
#layout_in_circle
#"layout_with_mds"
#plot by groups
#make clusters first
clust_obj = make_clusters(subgraph, membership = clusters$group)
# weights <- ifelse(crossing(male_clust, male_subgraph), 1, 100)
# layout <- layout_with_kk(male_subgraph, weights=weights)
# plot(male_subgraph, layout=layout)
prettyColors <- c("turquoise4", "azure4", "olivedrab","deeppink4", "blue")
communityColors <- prettyColors[membership(clust_obj)]
edge.weights <- function(community, network, weight.within = 100, weight.between = 1) {
bridges <- crossing(communities = community, graph = network)
weights <- ifelse(test = bridges, yes = weight.between, no = weight.within)
return(weights)
}
E(subgraph)$weight <- edge.weights(clust_obj, subgraph)
layout <- layout_with_fr(subgraph, weights=E(subgraph)$weight)
plot(subgraph, layout=layout, col = communityColors)
}
detect_communities(token.all, 'female', 10)
detect_communities(token.all, 'male', 10)
#create a token set with only generalized pos info
pos_replace <- function(toks.replace){
toks.replace <- toks.replace %>%
tokens_replace(pattern = c("*/NOUN", "*/VERB", "*/ADJ"), replacement = c("NOUN", "VERB", "ADJ"))
return(toks.replace)
}
token.pos <- pos_replace(token.all)
p_decdat <- data.frame() #initialize data frame
pos = c('verb', 'adj', 'noun') #pos to be analysed
for(j in 0:7){ #for loop to run for each decade
year = 1940 + j*10 #create decade variable
pos_counts <- rawcounts(token_filter("all", year, token.pos)) #find raw co-occurrence counts
male_pos <- pos_counts["male/characters", pos] #filter pos
male_p <- male_pos / sum(male_pos) #find empirical probability
male_pdat <- data.frame(pos = names(male_pos), p = male_p) #organise data frame
male_pdat$gender = "male" #assign gender
#do the same for females
female_pos <- pos_counts["female/characters", pos]
female_p <- female_pos / sum(female_pos)
female_pdat <- data.frame(pos = names(female_pos), p = female_p)
female_pdat$gender = "female"
p_decdat.temp <- rbind(male_pdat, female_pdat) #bind gender data
p_decdat.temp$year <- year #assign year
p_decdat <- rbind(p_decdat, p_decdat.temp) #bind ind. decade with overall
}
#plot for adjectives
ggplot(p_decdat[pos == "adj",], aes(x = year, y = p, color = gender)) +
geom_point(size = 1.3) + geom_smooth(method = "lm", aes(fill = gender), alpha = 0.1) +
geom_line(size = 0.8) + theme_minimal() + ggtitle("Probability of co-occurence with Adjectives") +
theme(axis.text = element_text(color = "black", size = 14), axis.title = element_text(color = "black", size = 15.5),
legend.text = element_text(color = "black", size = 14), legend.title = element_text(color = "black", size = 15.5),
panel.grid.major = element_line(colour = "grey50", size = 0.3), panel.grid.minor = element_line(colour = "grey50", size = 0.3))
#plot for adjectives
ggplot(p_decdat[pos == "adj",], aes(x = year, y = p, color = gender)) +
geom_point(size = 1.3) + geom_smooth(method = "lm", formula = y ~ x + I(x^2), aes(fill = gender), alpha = 0.1) +
geom_line(size = 0.8) + theme_minimal() + ggtitle("Probability of co-occurence with Adjectives") +
theme(axis.text = element_text(color = "black", size = 14), axis.title = element_text(color = "black", size = 15.5),
legend.text = element_text(color = "black", size = 14), legend.title = element_text(color = "black", size = 15.5),
panel.grid.major = element_line(colour = "grey50", size = 0.3), panel.grid.minor = element_line(colour = "grey50", size = 0.3))
#plot for verbs
ggplot(p_decdat[pos == "verb",], aes(x = year, y = p, color = gender)) +
geom_point(size = 1.2) + geom_smooth(method = "lm", formula = y ~ x + I(x^2), aes(fill = gender), alpha = 0.1) +
geom_line(size = 0.8) + theme_minimal() + ggtitle("Probability of co-occurence with Verbs") + theme_minimal() +
theme(axis.text = element_text(color = "black", size = 14), axis.title = element_text(color = "black", size = 15.5),
legend.text = element_text(color = "black", size = 14), legend.title = element_text(color = "black", size = 15.5),
panel.grid.major = element_line(colour = "grey50", size = 0.3), panel.grid.minor = element_line(colour = "grey50", size = 0.3))
#plot for nouns
ggplot(p_decdat[pos == "noun",], aes(x = year, y = p, color = gender)) +
geom_point(size = 1.2) +
geom_line(size = 0.8) + theme_minimal() + ggtitle("Probability of co-occurence with Nouns") + geom_smooth(method = "lm", aes(fill = gender), alpha = 0.1) +
theme(axis.text = element_text(color = "black", size = 14), axis.title = element_text(color = "black", size = 15.5),
legend.text = element_text(color = "black", size = 14), legend.title = element_text(color = "black", size = 15.5),
panel.grid.major = element_line(colour = "grey50", size = 0.3), panel.grid.minor = element_line(colour = "grey50", size = 0.3))
#plot for nouns
ggplot(p_decdat[pos == "noun",], aes(x = year, y = p, color = gender)) +
geom_point(size = 1.2) +
geom_line(size = 0.8) + theme_minimal() + ggtitle("Probability of co-occurence with Nouns") +
geom_smooth(method = "lm", formula = y ~ x + I(x^2), aes(fill = gender), alpha = 0.1) +
theme(axis.text = element_text(color = "black", size = 14), axis.title = element_text(color = "black", size = 15.5),
legend.text = element_text(color = "black", size = 14), legend.title = element_text(color = "black", size = 15.5),
panel.grid.major = element_line(colour = "grey50", size = 0.3), panel.grid.minor = element_line(colour = "grey50", size = 0.3))
print(communities)
#gender = 'male'
#DETECTING COMMUNITIES
#toks.all = token.all
#gender = 'female'
detect_communities <- function(toks.all, gender = 'male', nn = 10){
toks <- toks.all %>%
tokens_select(pattern = paste(gender, '/characters', sep = ''), selection = 'remove', padding = TRUE, window = 5)
#filter to keep only words that occur at least 10 times
dfm <-  toks %>% dfm() %>% dfm_trim(min_termfreq = 10)
filtered = colnames(dfm)
toks <- token.all %>%
tokens_select(pattern = filtered, selection = 'keep', padding = TRUE)
#feature co-occurrence matrix for males
fcmat = fcm(toks, context = c("window"),
count = c("weighted"), #words are weighted within the window
window = 5)
#fcmat[1:2,1:2] #a small portion of the feature co-occurrence matrix
graph = graph_from_adjacency_matrix(fcmat, weighted = TRUE) #create graph from matrix
edgelist <- get.data.frame(graph)
edgelist_m <- as.matrix(edgelist[ ,c("from", "to")])
graph <- graph_from_edgelist(edgelist_m, directed = FALSE)
graph <- set.edge.attribute(graph, "weight", value = edgelist$weight)
graph = simplify(graph, remove.loops = TRUE) #remove self-looping edges
#louvian communities
louvain <- cluster_louvain(graph, weights = E(graph)$weights)#detect communities
graph$community <- louvain$membership
#unique(male_graph$community)
#most important word in each community
communities <- data.frame()
for (i in unique(graph$community)) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# get size of each subgraph
size <- igraph::gorder(subgraph)
# get betweenness centrality
btwn <-  igraph::betweenness(subgraph)
communities <- communities %>%
dplyr::bind_rows(
data.frame(community = i,
n_characters = size,
most_important = names(which(btwn == max(btwn)))
)
)
}
communities = arrange(communities, desc(n_characters))
top_comm <- communities$community[1:5]
print(communities)
#knitr::kable(communities %>%
#               dplyr::select(community, n_characters, most_important))
#top five in each community
top_ten <- data.frame()
n = 0
for (i in top_comm) {
# create subgraphs for each community
subgraph <- induced_subgraph(graph, v = which(graph$community == i))
# for larger communities
#  if (igraph::gorder(subgraph) > 1055) {
n = n + 1
# get degree
degree <-  igraph::degree(subgraph)
# get top ten degrees
top <- names(head(sort(degree, decreasing = TRUE), nn))
result <- data.frame(community = i, rank = 1:nn, word = top)
# } else {
#   result <- data.frame(community = NULL, rank = NULL, character = NULL)
#}
top_ten <- top_ten %>%
dplyr::bind_rows(result)
}
print(top_ten)
write.csv(top_ten, paste(gender, '.csv', sep = ''))
print(paste('modularity =', modularity(louvain)))
n
# knitr::kable(
#   top_five %>%
#     tidyr::pivot_wider(names_from = rank, values_from = character)
# )
#Visualising the communities
subgraph <- induced_subgraph(graph, v = top_ten$word)
subgraph <- simplify(subgraph)
subgraph$community
nodes = data.frame(word = names(V(subgraph)))
group = rep(1:n, each = nn)
top_ten$group = group
clusters = inner_join(nodes, top_ten)
subgraph$community <- clusters$group
#unique(subgraph$community)
# give our nodes some properties, incl scaling them by degree and coloring them by community
V(subgraph)$size <- 5
V(subgraph)$frame.color <- "white"
V(subgraph)$color <- subgraph$community
#V(male_subgraph)$label <- V(male_subgraph)$name
V(subgraph)$label.cex <- 1.5
# also color edges according to their starting node
edge.start <- ends(subgraph, es = E(subgraph), names = F)[,1]
E(subgraph)$color <- V(subgraph)$color[edge.start]
E(subgraph)$arrow.mode <- 0
# only label central characters
#v_labels <- which(V(friends_graph)$name %in% friends)
#for (i in 1:length(V(friends_graph))) {
#  if (!(i %in% v_labels)) {
#    V(friends_graph)$label[i] <- ""
#  }
#}
#l2 <- layout_with_mds(male_subgraph)
#layout <- layout_with_kk(male_subgraph, weights=weights)
#plot(graph, layout=layout)
#plot(male_subgraph, rescale = T, layout = l2, main = "Male Graph")
#length(V(male_subgraph))
#visIgraph(male_subgraph) %>% visIgraphLayout(layout = "layout_with_mds") %>% visNodes(size = 12)
#layout_in_circle
#"layout_with_mds"
#plot by groups
#make clusters first
clust_obj = make_clusters(subgraph, membership = clusters$group)
# weights <- ifelse(crossing(male_clust, male_subgraph), 1, 100)
# layout <- layout_with_kk(male_subgraph, weights=weights)
# plot(male_subgraph, layout=layout)
prettyColors <- c("turquoise4", "azure4", "olivedrab","deeppink4", "blue")
communityColors <- prettyColors[membership(clust_obj)]
edge.weights <- function(community, network, weight.within = 100, weight.between = 1) {
bridges <- crossing(communities = community, graph = network)
weights <- ifelse(test = bridges, yes = weight.between, no = weight.within)
return(weights)
}
E(subgraph)$weight <- edge.weights(clust_obj, subgraph)
layout <- layout_with_fr(subgraph, weights=E(subgraph)$weight)
plot(subgraph, layout=layout, col = communityColors)
}
detect_communities(token.all, 'male', 10)
detect_communities(token.all, 'female', 10)
